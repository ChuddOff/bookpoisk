server:
  port: ${PORT:8080}
spring:
  datasource:
    url: ${SPRING_DATASOURCE_URL}
    username: ${SPRING_DATASOURCE_USERNAME}
    password: ${SPRING_DATASOURCE_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: update # Hibernate сам создаёт/обновляет таблицы по сущностям
    properties:
      hibernate:
        format_sql: true # true — красиво печатает SQL в логах.
        jdbc.time_zone: UTC # пишет/читает время в UTC.
  open-in-view: false # сессия закрывается до контроллера

  security:
    oauth2:
      client:
        registration:
          google: # здесь указали, что регистрация идет через google, поэтому spring security будет использовать все ссылки отсюда
            client-id: ${GOOGLE_CLIENT_ID}
            client-authentication-method: client_secret_basic
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: [ openid, email, profile ]
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}" # шаблон URL, на который Google вернёт код авторизации, {baseUrl} — твой бэкенд,{registrationId} — идентификатор клиента (google
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth # эндпоинт авторизации Google, куда Spring отправляет пользователя для логина/согласия.
            token-uri: https://oauth2.googleapis.com/token # сюда делается Post-запрос, с последующим получением JSON
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub

app:
  cors:
    allowed-origins: "https://bookpoisk.vercel.app"
  auth:
    frontend-success-url: "https://bookpoisk.vercel.app/auth/done"
    jwt:
      secret: ${APP_JWT_SECRET}     # длинный случайный ключ (HS256)
      access-ttl-seconds: 3600
